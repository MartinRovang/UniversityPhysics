\include{preamble}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{amsmath}
\usepackage{mathtools}

\begin{document}
% --------------------------------------------------------------
%                         FRONTPAGE
% --------------------------------------------------------------
{\fontfamily{cmr}\selectfont
\title{ \normalsize \textsc{}
		\\ [1.0cm] % How much upper margin
		%\HRule{0.5pt} \\
        \LARGE \textbf{\uppercase{Obligatorisk Oppgave 3}
        \HRule{0.5pt} \\ [0.5cm]
        INF-1400-Objekt-Orientert programmering
        %\HRule{2pt} \\ [0.5cm]
        \\
		\normalsize \today \vspace*{5\baselineskip}}
		}

        \date{}
\author{
		Martin Soria Røvang \\ 
        Universitetet i Tromsø \\}

% \begin{titlepage}
\clearpage\maketitle
\vspace{0.2\textheight}
{\centering
Inneholder \pageref{LastPage} \, sider, inkludert forside.\par
}
\thispagestyle{empty}
% \end{titlepage}

\newpage
\tableofcontents
\newpage
% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------


\section{Introduksjon}

I denne oppgaven ble en klone av spillet \emph{Mayhem} laget. Dette er et multiplayer-spill som består av to romskip som skal skyte på hverandre og passe på at de har nok drivstoff til å motstå gravitasjonen. Spillerne vil miste poeng hvis romskipet blir skutt ned eller kræsjer, og man får poeng hivs de skyter ned motstanderen sitt romskip.


\section{Teknisk bakgrunn}

\begin{itemize}
    \item \emph{Arv}: I denne oppgaven arves det fra pygame sin \emph{Sprites} og mellom egne definerte klasser.
    \item Initialisering direkte fra en annen klasse, f.eks \emph{Player1.\_\_init\_\_(self)} i Player2 sin \_\_init\_\_.
    \item \emph{Wrappers}: Wrapper er en funksjon som tar inn en funksjon for så gjøre noe rundt den funksjonen man tar inn, som f.eks finne ut hvor lang tid funksjonen brukte. Denne wrapperen kan brukes med en dekorator @ rundt funksjonen man vil ta tiden av.
\end{itemize}


\section{Design}



\begin{figure}[hbt!]
{\centering
    \includegraphics[width=0.90\textwidth]{out/um/um.pdf}
    \caption{UML diagram av prosjektet, nesten alle klassene arver fra pygame sin spriteklasse for å kunne bruke \emph{spritegroups}, dette vil gjøre det enklere å avgjøre kollisjoner.}
    \label{UML}
\par}
\end{figure}


\subsection{Game}
Klassen \emph{Game} er klassen som er \emph{hjernen} i programmet. Denne kobler sammen alle de andre klassene og funksjonene slik at vi får en logikk i spillet. Denne klassen vil ta for seg poeng fordeling ved å endre \emph{self.points} attributten til spillerne. Self.points brukes som variabelnavn i pygame sin tekst til skjerm funksjon slik at man til enhver tid kan se poengene til spillerne. Det er i denne klassen \emph{gameloop} metoden er, denne metoden vil kjøre løkken som oppdaterer objektene(spillerne, kuler osv.) og tegner dem ut på skjermen. I denne prosessen brukes pygame sin spritegroup.update og .draw funksjoner. Disse oppdaterer og tegner alle objektene som har blitt lagt inn i spritegruppen(liste). 

\subsection{Player1 og Player2}

Vi har to klasser for spillerne, Player1 og Player2. Spiller 2 arver fra spiller 1 fordi de er nesten helt like, men bruker andre knapper for å styre romskipet, og har forsjellige plasseringer av poeng/drivstoff informasjon. I denne klassen initialiseres bildene som romskipet skal ha med pygame sin load metode \emph{pygame.image.load}. Dette er to forskjellige bilder som viser romskipet med motor av og på, disse er vist i figur(\ref{skips}). Som man kan se på bildene så er ikke romskipet rektangulært, dette vil medføre til litt rar kollisjon da vi bruker rektangulær kollisjons-boks(hitbox). 

\begin{figure}[hbt!]
{\centering
    \includegraphics[width=0.15\textwidth]{ship1.jpg} \includegraphics[width=0.15\textwidth]{ship2.jpg}
    \caption{Modell av romskipene med motor av og på.}
    \label{skips}
\par}
\end{figure}


Spillerklassen har en metode som resetter startverdiene og legger til et minuspoeng, denne blir brukt hver gang et romskip blir skutt ned eller om man kræsjer. \\

Kontrollering av romskipene blir gjort fra \emph{controls} metoden ved hjelp av pygames sin \emph{get\_pressed} metode, den henter ut knappene som blir trykket på. Dette ble så brukt til å sjekke om knappene som er valgt til å skyte, fly og akselerere blir brukt. Ved bruk av \emph{eval} funksjonen kan man lage en variabel for knappene som skal brukes, slik at dette kunne endres i \emph{config.py} filen. \\

Rotasjon av skipet ble gjort ved bruk av pygame sin \emph{pygame.transform.rotate} metode, den tar inn en vinkelverdi som blir gitt fra \emph{controls} metoden. \\ 

Hvis motoren er av vil gravitasjonen dra skipet i y-retning, og hvis motoren er på vil gravitasjonen skru av og en fart vil bli lagt til i x- og y-retning basert på hvilken vinkel romskipet er i. Dette blir styrt med en sinus- og cosinus-funksjon, med vinkelen som argument. Dette vil skje kun hvis man har nok drivstoff så her er det også en \emph{if} test. Hastigheten er gitt matematisk i ligning(\ref{hastighet}).

\begin{equation}
    \vect{v}(x,y) = 
  \begin{cases}
    (0, g)\Delta t ,\,\textit{engine off} \\
    (cos(\theta), -sin(\theta))\alpha,\,\textit{engine on}
  \end{cases}
  \label{hastighet}
\end{equation}

Her er g gravitasjonen, $\alpha$ er en konstant(hvor stor hastighet), $\theta $ er vinkelen på romskipet og $\Delta t$ er FPS, slik at hvis man har 60 fps vil dette skje 60 ganger i sekunder $\Delta t = 60*sekunder$. Når motoren er på har det blitt valgt å fjerne akselerasjonen (tidsavhengigheten) for å gjøre det lettere å styre romskipet, dette ble gjort ved å sette hastigheten lik og ikke summe på som vi gjør med gravitasjonen.\\

\begin{figure}
\begin{equation}
    \vect{a}(x,y) = 
  \begin{cases}
    (0, g) ,\,\textit{engine off} \\
    (0, 0)\alpha,\,\textit{engine on}
  \end{cases}
\end{equation}
\label{hastighet}
\caption{Akselerasjonen til romskipene}
\end{figure}

Player2 klassen er så og si den samme, men med annen andre knapper for å kontrollere romskipet og annen posisjon for drivstoff og poeng informasjon, der player1 har informasjonen i venstre topphjørne og player2 har det i høyre topphjørne.





\subsection{Bullets}

Kulene skal komme ut i samme vinkel som romskipet, derfor har vinkelen til romskipet blitt brukt som argument i en cosinus- og sinus-funksjon i hastigheten til kulene. Når en spiller skyter ut kulene legges det en kule sprite i en spritegroup. Dette blir brukt sammen med sprite.groupcollide funksjonen til pygame for å teste kollisjon mellom vegger og spillere. Denne funksjonen vil returnere en dictionary med sprites som kolliderer, og deretter fjerne de fra sprite group-listen, hvis man har lagt inn dette som argument. Denne return dictionarien blir brukt til å tildele eller fjerne poeng til spillerne. Kulene ser som vist i figur(\ref{Kuler}).

\begin{figure}[hbt!]
{\centering
    \includegraphics[width=0.25\textwidth]{kuler.jpg}
    \caption{Kuler som kommer ut av romskipet.}
    \label{Kuler}
\par}
\end{figure}


\subsection{Walls}

Veggene i spillet er også sprites som har blitt lagt inn i spritegroups slik at at man kan teste for kollisjon mellom vegg, spillere og kuler. Her skal ingen av veggene forsvinne etter en kollisjon, derfor legges dette inn som argument i spritecollide-funksjonen til pygame at både kuler og romskip skal bli fjernet, men ikke veggene. 

\begin{figure}[hbt!]
    {\centering
        \includegraphics[width=0.25\textwidth]{vegg.jpg}
        \caption{En av veggene som er i spillet(den hvite streken).}
        \label{vegg}
    \par}
    \end{figure}





\subsection{Fuel}

Drivstoff-fat oppstår i et tilfeldig område på spillskjermen hvert 40 sekund(dette kan endres i \emph{config.py}). Disse vil fylle på drivstoff, og vil da hindre romskipet fra å kræsje i veggen pågrunn av gravitasjon(hvis motoren blir brukt da selfølgelig). Her ble \emph{time} modul fra python sine innebygde moduler brukt for å finne tiden(for når et fat skulle bli lagt ut). \emph{time.time()} vil gi antall sekunder siden denne funksjonen ble kalt på\footnote{On Windows, this function returns wall-clock seconds elapsed since the first call to this function, as a floating point number,\url{https://docs.python.org/3/library/time.html}}, ved å derfor ta differnansen mellom to slike kall kan man få tiden det har tatt (slutt-start). Dette ble brukt ved å først kalle time.time(), og deretter ha en ny midlertidig variabel som har samme verdi som time.time() + 40. Herfra blir det testa om time.time() har større verdi en denne, når denne endelig får større verdi så legges det ut et drivstoff-fat på et tilfeldig sted og deretter legges det til dette tidsintervallet på den midlertidige variabelen også testes alt på nytt. I figur(\ref{fuel}) kan man se et fat med drivstoff ute på spillskjermen.


\begin{figure}[hbt!]
    {\centering
        \includegraphics[width=0.25\textwidth]{fuel.jpg}
        \caption{Drivstoff-fat kan plukkes opp av romskipene, denne vil fylle drivstoffet helt opp når man flyr på den. Fatene spawner/oppstår hvert 40 sekund (dette kan endres i konfigurasjonsfilen).}
        \label{fuel}
    \par}
    \end{figure}


    \newpage
\section{Implementasjon}
    Koden er skrevet i Python versjon 3.7\footnote{https://www.python.org/}\\
    OS: Windows 10\\
    Systemtype: 64-bit OS, x64-basert prosessor\\
    Skjermkort: NVIDIA Geforce 920MX\\
    CPU: Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz\\
    RAM: 4GB\\
    Pygame \footnote{https://www.pygame.org/wiki/GettingStarted} Version: 1.9.4\\
    Numpy \footnote{http://www.numpy.org/} Version: 1.14.5\\
    



    \section{Diskusjon}

    Bruk av pygame sin sprite-klasse gjorde det enklere å håndtere forskjellige spill relaterte problemer som kollisjon. Her var gruppe oppdatering og tegning/draw, og fjerning av objekter allerede implementert. Ett problem som kan oppstå her er at man kan glemme at alle disse funksjonene kan bli ganske krevende da det underliggende i funksjonene er for løkker, og annet som kan være svært systemkrevende. FPS(frames per second) var ikke så bra under testing av spillet så her kunne man prøvd å optimalisere mer. Når man skyter så lager man veldig mange kuler. Dette er fordi at det ikke har blitt lagt inn noen restriksjon på hvor mange kuler som skal komme ut når man bruker skyteknappen, og derfor vil programmet bare skyte av så mange kuler den klarer(ved 60 fps vil det være 60 kuler i sekundet, så her kunne man optimalisert mer med tanke på dette). Laget også en dekorator-mønster for å gjøre det enklere med feilsøking/optimalisering. Her ble det brukt den innebygde time modulen for å finne hvor lang tid det tok å kjøre en funksjon, denne tiden ble summet opp for hver gang denne ble kjørt slik at man finner den kumulative summen. Antall funksjonskall ble også tatt vare på. Hvis man så avslutta programmet ville man se den kumulative summen av tid og antall funksjonskall for de(n) gitte funksjonen(e).

  


    \section{Evaluering}

    Programmet kjørte ganske tregt, og derfor kunne det ha vært bedre optimalisert. Tar man en titt på figur(\ref{profilings}) kan man se at \emph{Player.update} bruker en kumulativ sum på 2.1 sekunder og 8100 kall. Antall kall kan man egentlig ikke gjøre så mye med siden spillet er avhengig av en kjapp oppdatering av verdiene til spillerene, men her kunne man prøvd å optimalisere hvordan update funksjonen fungerer, og eventuell se om det er noen plasser man kunne ha lagt inn generatorer for å spare minne. Hvis man ser litt lengre opp ser man at bakgrunnen brukte veldig mye tid på kun 4051 kall. Dette ble optimalisert ved hjelp av eget diagnostikkverktøy forklart under.

    \begin{figure}[hbt!]
    {\centering
        \includegraphics[width=1\textwidth]{profiling.png}
        \caption{Profil av programmet, her kan man se de hvor lang tid de forskjellige funksjonene brukte og antall kall det var til dem. Her har det blitt brukt \emph{cProfiler} sammen med visualiseringsbiblioteket \emph{snakeviz}}. Pilene peker på antall kall of kumulativ sum for Player.update() metoden.
        \label{profilings}
    \par}
    \end{figure}

    Det ble også laget en egen profilerings-dekorator slik at man kunne teste en eller flere funksjoner. Dette ble gjort ved bruk av timer modulen, og ved å lage en $"$sandwhich$"$ med funksjonen som ble testa i midten av to time.time() funksjonskall. Med dette kunne jeg dekorere funksjoner jeg ville sjekke kumulativ sum av tid og antall kall på, slik som vist i figur(\ref{Kode1}).

    \begin{figure}[hbt!]
        \begin{lstlisting}
        @timer 
        def somefunction():
            .....


>> Cumsum/Calls: {'point_assigner_win': [0.0004951953887939453, 377], 'point_assigner_loss': [0.002472400665283203, 754]}
        \end{lstlisting}
    \caption{Hvordan dekoratoren ble brukt i koden, og resultat of utskrift gitt at to funksjoner var dekorert.}
    \label{Kode1}
    \end{figure}

Et problem her var at alle funksjonene kjørte i $"$evig tid$"$ fordi det er løkke som må kjøre så lenge man spiller, slik at her var det også implementert en metode som printer ut resultatet, denne må man legge inn sammen med \emph{if} testen som tok av seg å lukke vinduet.

Dette verktøyet brukte jeg for å optimalisere $"$Background$"$ funksjonen. Før optimalisering fikk man resultatet vist i figur(\ref{Kode2}), 

\begin{figure}[hbt!]
    \begin{lstlisting}
        Cumsum/Calls: {'background': [19.079365253448486, 1163]}
    \end{lstlisting}
\caption{Før optimalisering}
\label{Kode2}
\end{figure}
og etter optimalisering fikk man resultatet vist i figur(\ref{Kode3})

\begin{figure}[hbt!]
    \begin{lstlisting}
        Cumsum/Calls: {'background': [1.6295523643493652, 1471]}
    \end{lstlisting}
\caption{Etter optimalisering. Her har vi optimalisert betydelig, da vi har kumulativ tid på 1.62 sekunder med flere funksjons-kall enn før optimalisering.}
\label{Kode3}
\end{figure}

Dette ble gjort ved å legge til .convert() etter at man lastet inn bilde med pygame.load(), dette vil formatere pikselene til bilde til å ha samme format som flaten.\footnote{\url{http://www.pygame.org/docs/ref/surface.html\#pygame.Surface.convert}}

    \section{Konklusjon}

    I dette prosjektet ble en klone av spillet \emph{Mayhem} laget med hensyn på objekt-orientert programmering. Ved hjelp av arv fra pygame sin sprite-klasse kunne man enkelt oppdatere, tegne og sjekke for kollisjon mellom alle objekter man hadde laget. Den største utfordringen er å få spillet optimalisert nok til at det var behagelig å spille, noe som ikke har blitt gjort her og dermed kan man forvente lav fps(frame per second). cProfiler ble brukt til å se hvilke funksjoner som var krevende, men dette var noe vanskelig å bruke da det var mange tredjeparts-moduler/funskjoner(pygame, sprites etc), men noe optimaliserings-problemet ble løst med eget diagnostikk-verktøy diskutert i rapporten.

\clearpage
\newpage
\section{Part II}
\subsection{1}

En klasse er en slags blåprint for å lage objekter, dette kan ses på som en fabrikk som lager biler, der objekter er bilene og fabrikkene er klassene.

    \begin{lstlisting}
class fabrikk:
        def __init__(self, wheelsize, color, motor):
            wheel.self = wheelsize
            color.self = color
            motor.self = motor
        def functions_that_does_stuff(self):
            ...

Bil1 = (50, 'green', 'RollsRoyce100X')
    \end{lstlisting}

I denne kodesnippeten over er et eksempel på fabrikk/bil metaforet.




\subsection{2}

Arv(Inheritance) er at man kan $"$kopiere$"$ en annen klasse, og derfra endre på akuratt de funksjonene/atributtene man ønsker, dette kan brukes hvis man for eksempel skal ha en ny klasse som er ganske lik en annen, men man må endre litt på hvordan en/flere funksjon(er) fungerer. Syntaksen for dette er vist i figur(\ref{arv}).

\begin{figure}[hbt!]
    \begin{lstlisting}
    class Child(Parent):
        ....
    \end{lstlisting}
\caption{Child arver fra Parent}
\label{arv}
\end{figure}


\subsection{3}


\emph{Is-a} relasjon kommer fra det å arve fra en klasse, og \emph{has-a} kommer fra det å arve fra flere klasser, slik at man arver funksjoner fra både Parent1 og Parent2. Dette blir analogt til at et barn har øyne fra far og nese fra mor. [(p.20-23)\cite{Dustyphil}]


\subsection{4}

\emph{Encapsulation} er det å gjemme implementasjon bak grensesnittet i programmet ditt, i python kan man ikke blokkere noen ute av deler av koden(utenom å kompilere til .exe eller annet.) så derfor har det blitt laget en konvensjon der man bruker \emph{\_.} før en funksjon/klasse/variabel som betyr at dette er \emph{privat} og dermed ikke bør endres. Dette kan brukes hvis hvis disse har systemkritiske funksjoner som kan ødelegge programmet hvis disse endres på.

\subsection{5}

Polymorfisme er det at man har noe som endrer seg basert på hva det skal gjøre. Hvis vi for eksempel har en klasse som er en gjenstand, og denne gjenstanden skal ha muligheten til å kun bevege seg diagonalt. Da vil man har en metode som heter \emph{move}. Videre vil man at en gjenstand også skal kunne bevege seg, men denne ganger kun i en retning. Herfra kan man arve fra den første klassen og endre på move funksjonen slik at objekter fra dette kun beveger seg i en retning.
Her har man da polymorfisme fordi nå kan man f.eks kalle move på objektene uten å tenke over hva de er for noe også vil de bevege seg med forskjellige regler, dette er også kalt \emph{duck typing}, fra $"$\emph{if it walks like a duck or swims like a duck, it's a duck}.$"$[(p.22-23)\cite{Dustyphil}].







% --------------------------------------------------------------
%     Reference og appendix
% --------------------------------------------------------------
\clearpage
\newpage
\section{Appendix}
\section{Referanser}
\begingroup
\renewcommand{\section}[2]{}%
%\renewcommand{\chapter}[2]{}% for other classes
\bibliographystyle{plainnat}
\bibliography{bibl}
\endgroup



% --------------------------------------------------------------
%     You don't have to mess with anything below this line.
% --------------------------------------------------------------
 





\end{document}


